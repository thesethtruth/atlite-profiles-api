import pandas as pd
import numpy as np
import plotly.express as px
from pathlib import Path
from pydantic import BaseModel, Field
from typing import List, Dict, Optional, Union, Literal

from .cutout_processing import (
    get_wind_profile,
    get_solar_profile,
    get_available_turbine_list,
    get_turbine_data,
)


class ProfileConfig(BaseModel):
    """
    ProfileConfig defines the configuration parameters required for generating renewable energy profiles.

    Attributes:
        output_dir (Path): The directory where generated profiles and output files will be saved.
        base_path (Path): The base directory path containing input data files.
        cutouts (List[Path]): A list of file paths to weather cutout NetCDF files (e.g., ERA5 datasets) representing different years.
            These files are used as input for profile generation. By default, includes cutouts from 1987, 2012, 2021, 2022, 2023, and 2024.
        location (Dict[str, float]): A dictionary specifying the geographic location for profile generation, with keys 'lat' (latitude)
            and 'lon' (longitude). Defaults to latitude 52.705 and longitude 4.770.

    This configuration class is intended to be used as input to profile generation routines, ensuring all necessary paths and parameters
    are specified in a structured and validated manner.
    """

    """Base configuration for profile generation."""

    output_dir: Path
    base_path: Path
    cutouts: List[Path] = Field(
        default_factory=lambda: [
            Path("europe-1987-era5.nc"),
            Path("europe-2012-era5.nc"),
            Path("europe-2021-era5.nc"),
            Path("europe-2022-era5.nc"),
            Path("europe-2023-era5.nc"),
            Path("europe-2024-era5.nc"),
        ],
        description="List of the cutouts (weather years) you want to generate data from",
    )
    location: Dict[str, float] = Field(
        default_factory=lambda: {"lat": 52.705, "lon": 4.770}
    )


class WindConfig(BaseModel):
    """Configuration for wind profile generation."""

    turbine_model: str = "NREL_ReferenceTurbine_2020ATB_4MW"
    output_subdir: str = "wind_profiles"

    # advanced post init validation to ensure the turbine model is valid.
    # it must be from the list generated by ProfileGenerator.list_available_turbines()

    def model_post_init(self, context):
        available_turbines = get_available_turbine_list()
        # read the custom_tubines folder for yaml names, these are also valid

        if self.turbine_model not in available_turbines:
            raise ValueError(
                f"Invalid turbine model '{self.turbine_model}'. "
                f"Available models are: {available_turbines}"
            )


class SolarConfig(BaseModel):
    """Configuration for solar profile generation."""

    slopes: List[float] = Field(default_factory=lambda: [30, 15, 15])
    azimuths: List[float] = Field(default_factory=lambda: [180, 90, 270])
    panel_model: str = "CSi"
    output_subdir: str = "solar_profiles"


class ProfileGenerator:
    """Generator for wind and solar profiles."""

    def __init__(
        self,
        profile_config: ProfileConfig = None,
        wind_config: WindConfig = None,
        solar_config: SolarConfig = None,
    ):
        """Initialize the profile generator with configurations."""
        self.config = profile_config or ProfileConfig()
        self.wind_config = wind_config or WindConfig()
        self.solar_config = solar_config or SolarConfig()

        # Create output directories if they don't exist
        self.wind_output_dir = self.config.output_dir / self.wind_config.output_subdir
        self.solar_output_dir = self.config.output_dir / self.solar_config.output_subdir
        self.wind_output_dir.mkdir(parents=True, exist_ok=True)
        self.solar_output_dir.mkdir(parents=True, exist_ok=True)

        # Store generated profiles
        self.wind_profiles = {}
        self.solar_profiles = {}

    def generate_wind_profiles(self) -> Dict[str, pd.Series]:
        """Generate wind profiles for all cutouts."""
        profiles = {}

        for cutout in self.config.cutouts:
            cutout_path = self.config.base_path / cutout
            cutout_year = cutout.name.split("-")[1]

            profile_key = f"{cutout_year}_{self.wind_config.turbine_model}"
            filename = f"{profile_key}.csv"
            filepath = self.wind_output_dir / filename

            # Check if file already exists
            if filepath.exists():
                print(
                    f"Wind profile for {cutout_year} already exists at {filepath}, loading existing file"
                )
                wind_profile = pd.read_csv(
                    filepath, index_col=0, parse_dates=True
                ).squeeze()
                profiles[profile_key] = wind_profile
                print(f"Full load hours: {wind_profile.sum()}")
            else:
                print(
                    f"Generating wind profile for {cutout_year} using {self.wind_config.turbine_model}"
                )

                wind_profile = get_wind_profile(
                    self.config.location["lat"],
                    self.config.location["lon"],
                    cutout_path=cutout_path,
                    turbine_model=self.wind_config.turbine_model,
                )

                profiles[profile_key] = wind_profile

                print(f"Full load hours: {wind_profile.sum()}")

                # Save profile to file
                wind_profile.to_csv(filepath)
                print(f"Saved wind profile to {filepath}")

        self.wind_profiles = profiles
        return profiles

    def generate_solar_profiles(self) -> Dict[str, pd.Series]:
        """Generate solar profiles for all cutouts and panel orientations."""
        profiles = {}

        for cutout in self.config.cutouts:
            cutout_path = self.config.base_path / cutout
            cutout_year = cutout.name.split("-")[1]

            for slope, azimuth in zip(
                self.solar_config.slopes, self.solar_config.azimuths
            ):
                profile_key = f"{cutout_year}_slope{slope}_azimuth{azimuth}"
                filename = f"{profile_key}.csv"
                filepath = self.solar_output_dir / filename

                # Check if file already exists
                if filepath.exists():
                    print(
                        f"Solar profile for {cutout_year} with slope={slope}, azimuth={azimuth} already exists at {filepath}, loading existing file"
                    )
                    solar_profile = pd.read_csv(
                        filepath, index_col=0, parse_dates=True
                    ).squeeze()
                    profiles[profile_key] = solar_profile
                    print(f"Full load hours: {solar_profile.sum()}")
                else:
                    print(
                        f"Generating solar profile for {cutout_year} with slope={slope}, azimuth={azimuth}"
                    )

                    solar_profile = get_solar_profile(
                        self.config.location["lat"],
                        self.config.location["lon"],
                        slope=slope,
                        azimuth=azimuth,
                        cutout_path=cutout_path,
                        panel_model=self.solar_config.panel_model,
                    )

                    profiles[profile_key] = solar_profile

                    print(f"Full load hours: {solar_profile.sum()}")

                    # Save profile to file
                    solar_profile.to_csv(filepath)
                    print(f"Saved solar profile to {filepath}")

        self.solar_profiles = profiles
        return profiles

    def visualize_wind_profiles(self):
        """Visualize wind profiles."""
        if not self.wind_profiles:
            print("No wind profiles to visualize. Generate profiles first.")
            return

        # Create a DataFrame from all profiles
        df = pd.DataFrame(self.wind_profiles)

        # Plot the profiles
        fig = px.line(df, title="Wind Generation Profiles")
        fig.update_layout(
            yaxis_title="Generation [p.u.]", xaxis_title="Time", showlegend=True
        )
        fig.show()

        return fig

    def visualize_solar_profiles_monthly(
        self, color_key: Literal["slope", "azimuth", "year"] = "slope"
    ):
        """Visualize solar profiles by month."""
        if not self.solar_profiles:
            # Try to load profiles from files
            self._load_solar_profiles_from_files()

            if not self.solar_profiles:
                print("No solar profiles to visualize. Generate profiles first.")
                return

        # Create a DataFrame for monthly aggregation
        df_total = pd.DataFrame()

        for profile_key, profile in self.solar_profiles.items():
            parts = profile_key.split("_")
            year = parts[0]
            slope = parts[1].replace("slope", "")
            azimuth = parts[2].replace("azimuth", "")

            # Convert to DataFrame if it's a Series
            if isinstance(profile, pd.Series):
                df = profile.to_frame(name="solar_generation")
            else:
                df = profile

            # Resample to monthly
            df_month = df.resample("M").sum()
            df_month[["year", "slope", "azimuth"]] = [year, slope, azimuth]
            df_month["month"] = df_month.index.month_name()

            df_total = pd.concat([df_total, df_month], axis=0)

        # Plot the monthly generation
        df_total["slope"] = df_total["slope"].astype(str)
        fig = px.scatter(
            df_total,
            title="Generation per month of 1 MWp solar installation",
            x="month",
            y="solar_generation",
            color=color_key,
            template="simple_white",
            opacity=0.7,
        )
        fig.update_layout(
            yaxis_title="Generation [MWh]", xaxis_title="Month", showlegend=True
        )
        fig.show()

        return fig

    def _load_solar_profiles_from_files(self):
        """Load solar profiles from files."""
        profiles = {}

        if not self.solar_output_dir.exists():
            return profiles

        for file in self.solar_output_dir.glob("*.csv"):
            profile_key = file.stem
            profile = pd.read_csv(file, index_col=0, parse_dates=True)
            profiles[profile_key] = profile

        self.solar_profiles = profiles
        return profiles

    @staticmethod
    def calculate_rotor_power_density(diameter: float, power: float) -> float:
        """
        Calculate the rotor power density of a wind turbine.

        Parameters:
        diameter (float): Diameter of the rotor in meters.
        power (float): Power of the turbine in MW.

        Returns:
        float: Rotor power density in W/m^2.
        """
        rotor_area = np.pi * (diameter / 2) ** 2  # Area in square meters
        power_watts = power * 1e6  # Convert MW to W
        power_density = power_watts / rotor_area  # Power density in W/m^2
        return power_density

    @staticmethod
    def get_turbine_details(turbine_model: str):
        """Get details for a specific turbine model."""
        return get_turbine_data(turbine_model)


if __name__ == "__main__":
    # Configuration variables
    # You can modify these variables to customize the profile generation

    # General configuration
    profile_type = "solar"  # Options: "wind", "solar", "both"
    latitude = 51.4713
    longitude = 5.4186
    visualize_results = True
    output_dir = "eindhoven_energy_hubs"

    # Wind-specific configuration
    turbine_model = "NREL_ReferenceTurbine_2020ATB_4MW"
    list_turbines = True

    # Solar-specific configuration
    slopes = [35, 15, 15]
    # slopes = [15]
    azimuths = [180, 90, 270]
    # azimuths = [270]
    panel_model = "CSi"

    # List available turbines if requested
    if list_turbines:
        ProfileGenerator.list_available_turbines()
    else:
        # Create configurations
        profile_config = ProfileConfig(
            location={"lat": latitude, "lon": longitude},
            base_path=Path("/mnt/c/Users/BERC2/Data"),
            output_dir=Path(output_dir),
            cutouts=[
                Path("europe-1987-era5.nc"),
                Path("europe-2012-era5.nc"),
                Path("europe-2021-era5.nc"),
                Path("europe-2022-era5.nc"),
                Path("europe-2023-era5.nc"),
                Path("europe-2024-era5.nc"),
            ],
        )

        wind_config = WindConfig(turbine_model=turbine_model)

        solar_config = SolarConfig(
            slopes=slopes,
            azimuths=azimuths,
            panel_model=panel_model,
            output_subdir="solar_profiles",
        )

        # Create generator
        generator = ProfileGenerator(
            profile_config=profile_config,
            wind_config=wind_config,
            solar_config=solar_config,
        )

        # Generate profiles
        if profile_type in ["wind", "both"]:
            generator.generate_wind_profiles()
            if visualize_results:
                generator.visualize_wind_profiles()

        if profile_type in ["solar", "both"]:
            generator.generate_solar_profiles()
        if visualize_results:
            generator.visualize_solar_profiles_monthly(color_key="azimuth")
