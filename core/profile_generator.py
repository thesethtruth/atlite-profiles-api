import logging
from pathlib import Path
from typing import Any, Dict, List, Literal

import numpy as np
import pandas as pd
import plotly.express as px
import yaml
from pydantic import BaseModel, Field

from .cutout_processing import (
    get_available_solar_technology_list,
    get_available_turbine_list,
    get_solar_profile,
    get_turbine_data,
    get_wind_profile,
)
from .models import SolarTechnologyConfig, WindTurbineConfig

logger = logging.getLogger(__name__)


class ProfileConfig(BaseModel):
    """Base configuration for profile generation."""

    output_dir: Path
    base_path: Path
    cutouts: List[Path] = Field(
        default_factory=lambda: [
            Path("europe-1987-era5.nc"),
            Path("europe-2012-era5.nc"),
            Path("europe-2021-era5.nc"),
            Path("europe-2022-era5.nc"),
            Path("europe-2023-era5.nc"),
            Path("europe-2024-era5.nc"),
        ],
        description=(
            "List of weather-year cutout files used as input for profile generation."
        ),
    )
    location: Dict[str, float] = Field(
        default_factory=lambda: {"lat": 52.705, "lon": 4.770}
    )


class WindConfig(BaseModel):
    """Configuration for wind profile generation."""

    turbine_model: str = "NREL_ReferenceTurbine_2020ATB_4MW"
    turbine_config: WindTurbineConfig | None = None
    output_subdir: str = "wind_profiles"

    # advanced post init validation to ensure the turbine model is valid.
    # it must be from the list generated by ProfileGenerator.list_available_turbines()

    def model_post_init(self, context):
        if self.turbine_config is not None:
            return

        available_turbines = get_available_turbine_list()
        # read the custom_tubines folder for yaml names, these are also valid

        if self.turbine_model not in available_turbines:
            raise ValueError(
                f"Invalid turbine model '{self.turbine_model}'. "
                f"Available models are: {available_turbines}"
            )

    def turbine_name(self) -> str:
        if self.turbine_config is not None:
            return self.turbine_config.name
        return self.turbine_model

    def atlite_turbine(self) -> str | dict[str, object]:
        if self.turbine_config is not None:
            return self.turbine_config.to_atlite_turbine()
        custom_payload = self._custom_turbine_payload()
        if custom_payload is not None:
            return custom_payload
        return self.turbine_model

    def _custom_turbine_payload(self) -> dict[str, object] | None:
        custom_file = Path("config/wind") / f"{self.turbine_model}.yaml"
        if not custom_file.exists():
            return None
        with custom_file.open(encoding="utf-8") as handle:
            raw = yaml.safe_load(handle)
        if not isinstance(raw, dict):
            raise ValueError(
                "Invalid custom turbine definition for "
                f"'{self.turbine_model}': expected object YAML."
            )
        return self._normalize_custom_turbine_payload(raw)

    def _normalize_custom_turbine_payload(
        self, payload: dict[str, Any]
    ) -> dict[str, object]:
        # Already in atlite YAML shape.
        if "HUB_HEIGHT" in payload and "V" in payload and "POW" in payload:
            normalized = dict(payload)
            normalized.setdefault("name", self.turbine_model)
            return normalized

        # Support API/CLI schema style persisted to config/wind.
        if {
            "hub_height_m",
            "wind_speeds",
            "power_curve_mw",
        }.issubset(payload.keys()):
            config = WindTurbineConfig.model_validate(
                {
                    "name": payload.get("name", self.turbine_model),
                    "hub_height_m": payload["hub_height_m"],
                    "wind_speeds": payload["wind_speeds"],
                    "power_curve_mw": payload["power_curve_mw"],
                    "rated_power_mw": payload.get("rated_power_mw"),
                    "manufacturer": payload.get("manufacturer"),
                    "source": payload.get("source"),
                }
            )
            return config.to_atlite_turbine()

        raise ValueError(
            "Invalid custom turbine definition for "
            f"'{self.turbine_model}': missing required turbine fields."
        )


class SolarConfig(BaseModel):
    """Configuration for solar profile generation."""

    slopes: List[float] = Field(default_factory=lambda: [30, 15, 15])
    azimuths: List[float] = Field(default_factory=lambda: [180, 90, 270])
    panel_model: str = "CSi"
    panel_config: SolarTechnologyConfig | None = None
    output_subdir: str = "solar_profiles"

    def model_post_init(self, context):
        if self.panel_config is not None:
            return

        available_models = get_available_solar_technology_list()
        if self.panel_model not in available_models:
            raise ValueError(
                f"Invalid panel model '{self.panel_model}'. "
                f"Available models are: {available_models}"
            )

    def panel_name(self) -> str:
        if self.panel_config is not None:
            return self.panel_config.name
        return self.panel_model

    def atlite_panel(self) -> str | dict[str, object]:
        if self.panel_config is not None:
            return self.panel_config.to_atlite_panel()
        custom_payload = self._custom_panel_payload()
        if custom_payload is not None:
            return custom_payload
        return self.panel_model

    def _custom_panel_payload(self) -> dict[str, object] | None:
        custom_file = Path("config/solar") / f"{self.panel_model}.yaml"
        if not custom_file.exists():
            return None
        with custom_file.open(encoding="utf-8") as handle:
            raw = yaml.safe_load(handle)
        if not isinstance(raw, dict):
            raise ValueError(
                "Invalid custom solar definition for "
                f"'{self.panel_model}': expected object YAML."
            )
        return self._normalize_custom_panel_payload(raw)

    def _normalize_custom_panel_payload(
        self, payload: dict[str, Any]
    ) -> dict[str, object]:
        config = SolarTechnologyConfig.from_payload(
            payload, default_name=self.panel_model
        )
        return config.to_atlite_panel()


class ProfileGenerator:
    """Generator for wind and solar profiles."""

    def __init__(
        self,
        profile_config: ProfileConfig = None,
        wind_config: WindConfig = None,
        solar_config: SolarConfig = None,
    ):
        """Initialize the profile generator with configurations."""
        self.config = profile_config or ProfileConfig()
        self.wind_config = wind_config or WindConfig()
        self.solar_config = solar_config or SolarConfig()

        # Create output directories if they don't exist
        self.wind_output_dir = self.config.output_dir / self.wind_config.output_subdir
        self.solar_output_dir = self.config.output_dir / self.solar_config.output_subdir
        self.wind_output_dir.mkdir(parents=True, exist_ok=True)
        self.solar_output_dir.mkdir(parents=True, exist_ok=True)

        # Store generated profiles
        self.wind_profiles = {}
        self.solar_profiles = {}

    def generate_wind_profiles(self) -> Dict[str, pd.Series]:
        """Generate wind profiles for all cutouts."""
        profiles = {}

        for cutout in self.config.cutouts:
            cutout_path = self.config.base_path / cutout
            cutout_year = cutout.name.split("-")[1]

            profile_key = f"{cutout_year}_{self.wind_config.turbine_name()}"
            filename = f"{profile_key}.csv"
            filepath = self.wind_output_dir / filename

            # Check if file already exists
            if filepath.exists():
                logger.info(
                    "Wind profile for %s already exists at %s, loading existing file",
                    cutout_year,
                    filepath,
                )
                wind_profile = pd.read_csv(
                    filepath, index_col=0, parse_dates=True
                ).squeeze()
                profiles[profile_key] = wind_profile
                logger.info(
                    "Wind full load hours for %s: %s", cutout_year, wind_profile.sum()
                )
            else:
                logger.info(
                    "Generating wind profile for %s using %s",
                    cutout_year,
                    self.wind_config.turbine_name(),
                )

                wind_profile = get_wind_profile(
                    self.config.location["lat"],
                    self.config.location["lon"],
                    cutout_path=cutout_path,
                    turbine=self.wind_config.atlite_turbine(),
                )

                profiles[profile_key] = wind_profile

                logger.info(
                    "Wind full load hours for %s: %s", cutout_year, wind_profile.sum()
                )

                # Save profile to file
                wind_profile.to_csv(filepath)
                logger.info("Saved wind profile to %s", filepath)

        self.wind_profiles = profiles
        return profiles

    def generate_solar_profiles(self) -> Dict[str, pd.Series]:
        """Generate solar profiles for all cutouts and panel orientations."""
        profiles = {}

        for cutout in self.config.cutouts:
            cutout_path = self.config.base_path / cutout
            cutout_year = cutout.name.split("-")[1]

            for slope, azimuth in zip(
                self.solar_config.slopes, self.solar_config.azimuths
            ):
                profile_key = f"{cutout_year}_slope{slope}_azimuth{azimuth}"
                filename = f"{profile_key}.csv"
                filepath = self.solar_output_dir / filename

                # Check if file already exists
                if filepath.exists():
                    logger.info(
                        "Solar profile for %s with slope=%s, azimuth=%s "
                        "already exists at %s, loading existing file",
                        cutout_year,
                        slope,
                        azimuth,
                        filepath,
                    )
                    solar_profile = pd.read_csv(
                        filepath, index_col=0, parse_dates=True
                    ).squeeze()
                    profiles[profile_key] = solar_profile
                    logger.info(
                        "Solar full load hours for %s slope=%s azimuth=%s: %s",
                        cutout_year,
                        slope,
                        azimuth,
                        solar_profile.sum(),
                    )
                else:
                    logger.info(
                        "Generating solar profile for %s with slope=%s, azimuth=%s",
                        cutout_year,
                        slope,
                        azimuth,
                    )

                    solar_profile = get_solar_profile(
                        self.config.location["lat"],
                        self.config.location["lon"],
                        slope=slope,
                        azimuth=azimuth,
                        cutout_path=cutout_path,
                        panel_model=self.solar_config.atlite_panel(),
                    )

                    profiles[profile_key] = solar_profile

                    logger.info(
                        "Solar full load hours for %s slope=%s azimuth=%s: %s",
                        cutout_year,
                        slope,
                        azimuth,
                        solar_profile.sum(),
                    )

                    # Save profile to file
                    solar_profile.to_csv(filepath)
                    logger.info("Saved solar profile to %s", filepath)

        self.solar_profiles = profiles
        return profiles

    def visualize_wind_profiles(self):
        """Visualize wind profiles."""
        if not self.wind_profiles:
            logger.warning("No wind profiles to visualize. Generate profiles first.")
            return

        # Create a DataFrame from all profiles
        df = pd.DataFrame(self.wind_profiles)

        # Plot the profiles
        fig = px.line(df, title="Wind Generation Profiles")
        fig.update_layout(
            yaxis_title="Generation [p.u.]", xaxis_title="Time", showlegend=True
        )
        fig.show()

        return fig

    def visualize_solar_profiles_monthly(
        self, color_key: Literal["slope", "azimuth", "year"] = "slope"
    ):
        """Visualize solar profiles by month."""
        if not self.solar_profiles:
            # Try to load profiles from files
            self._load_solar_profiles_from_files()

            if not self.solar_profiles:
                logger.warning(
                    "No solar profiles to visualize. Generate profiles first."
                )
                return

        # Create a DataFrame for monthly aggregation
        df_total = pd.DataFrame()

        for profile_key, profile in self.solar_profiles.items():
            parts = profile_key.split("_")
            year = parts[0]
            slope = parts[1].replace("slope", "")
            azimuth = parts[2].replace("azimuth", "")

            # Convert to DataFrame if it's a Series
            if isinstance(profile, pd.Series):
                df = profile.to_frame(name="solar_generation")
            else:
                df = profile

            # Resample to monthly
            df_month = df.resample("M").sum()
            df_month[["year", "slope", "azimuth"]] = [year, slope, azimuth]
            df_month["month"] = df_month.index.month_name()

            df_total = pd.concat([df_total, df_month], axis=0)

        # Plot the monthly generation
        df_total["slope"] = df_total["slope"].astype(str)
        fig = px.scatter(
            df_total,
            title="Generation per month of 1 MWp solar installation",
            x="month",
            y="solar_generation",
            color=color_key,
            template="simple_white",
            opacity=0.7,
        )
        fig.update_layout(
            yaxis_title="Generation [MWh]", xaxis_title="Month", showlegend=True
        )
        fig.show()

        return fig

    def _load_solar_profiles_from_files(self):
        """Load solar profiles from files."""
        profiles = {}

        if not self.solar_output_dir.exists():
            return profiles

        for file in self.solar_output_dir.glob("*.csv"):
            profile_key = file.stem
            profile = pd.read_csv(file, index_col=0, parse_dates=True)
            profiles[profile_key] = profile

        self.solar_profiles = profiles
        return profiles

    @staticmethod
    def calculate_rotor_power_density(diameter: float, power: float) -> float:
        """
        Calculate the rotor power density of a wind turbine.

        Parameters:
        diameter (float): Diameter of the rotor in meters.
        power (float): Power of the turbine in MW.

        Returns:
        float: Rotor power density in W/m^2.
        """
        rotor_area = np.pi * (diameter / 2) ** 2  # Area in square meters
        power_watts = power * 1e6  # Convert MW to W
        power_density = power_watts / rotor_area  # Power density in W/m^2
        return power_density

    @staticmethod
    def get_turbine_details(turbine_model: str):
        """Get details for a specific turbine model."""
        return get_turbine_data(turbine_model)


if __name__ == "__main__":
    # Configuration variables
    # You can modify these variables to customize the profile generation

    # General configuration
    profile_type = "solar"  # Options: "wind", "solar", "both"
    latitude = 51.4713
    longitude = 5.4186
    visualize_results = True
    output_dir = "eindhoven_energy_hubs"

    # Wind-specific configuration
    turbine_model = "NREL_ReferenceTurbine_2020ATB_4MW"
    list_turbines = True

    # Solar-specific configuration
    slopes = [35, 15, 15]
    # slopes = [15]
    azimuths = [180, 90, 270]
    # azimuths = [270]
    panel_model = "CSi"

    # List available turbines if requested
    if list_turbines:
        ProfileGenerator.list_available_turbines()
    else:
        # Create configurations
        profile_config = ProfileConfig(
            location={"lat": latitude, "lon": longitude},
            base_path=Path("data"),
            output_dir=Path(output_dir),
            cutouts=[
                Path("europe-1987-era5.nc"),
                Path("europe-2012-era5.nc"),
                Path("europe-2021-era5.nc"),
                Path("europe-2022-era5.nc"),
                Path("europe-2023-era5.nc"),
                Path("europe-2024-era5.nc"),
            ],
        )

        wind_config = WindConfig(turbine_model=turbine_model)

        solar_config = SolarConfig(
            slopes=slopes,
            azimuths=azimuths,
            panel_model=panel_model,
            output_subdir="solar_profiles",
        )

        # Create generator
        generator = ProfileGenerator(
            profile_config=profile_config,
            wind_config=wind_config,
            solar_config=solar_config,
        )

        # Generate profiles
        if profile_type in ["wind", "both"]:
            generator.generate_wind_profiles()
            if visualize_results:
                generator.visualize_wind_profiles()

        if profile_type in ["solar", "both"]:
            generator.generate_solar_profiles()
        if visualize_results:
            generator.visualize_solar_profiles_monthly(color_key="azimuth")
